1. Создайте вектор из следующих целочисленных элементов: { 1, 8, 7, 4, 3, 6, 2, 5 }. Воспользуйтесь алгоритмом std::sort, чтобы разместить сначала чётные числа, а затем нечётные (если оба числа одной чётности, то сначала идёт меньшее).
Сигнатура функции сортировки:
Compare(const T& e1, const T& e2) -> bool (true, если e1 должен быть раньше e2).
Передайте функцию сортировки через лямбду.

2. При помощи алгоритма std::copy_if найдите все те числа, которые больше N. Передайте N=5 как элемент функтора.

3*. Изучите действие функтора std::bind. Попробуйте использовать его для формирования условия из стандартного функтора std::greater (модуль <functional>).

4. Все алгоритмы могут выводить результат прямо в поток вывода. Попробуйте воспользоваться объектом std::ostream_iterator<TElement, TChar> (из модуля <iterator>) для прямого вывода результата работы алгоритма.

5. У берега реки водятся { L"пескарь", L"мидия", L"рак" }, а на глубине — { L"бычок", L"окунь", L"мидия" }. С помощью операций над множествами выведите 
а) всех обитателей реки, 
б) тех, кто водится по всей реке,
в) тех, кто водится около берега, но не на глубине.

6. Дано следующее мульти-отображение:
{
	{ 1, L"адзін" },
	{ 1, L"один" },
	{ 1, L"one" },
	{ 2, L"два" },
	{ 2, L"two" },
	{ 3, L"тры" },
	{ 3, L"три" },
	{ 3, L"three" },
	{ 4, L"чатыры" },
	{ 4, L"четыре" },
	{ 4, L"four" },
}
При помощи методов lower_bound и upper_bound выведите все доступные варианты написания числа N. Если нету ни одного варианта, выведите соответствующее сообщение. Проверьте работу для N=3, N=5.
Постарайтесь организовать код в отдельных функциях.
